<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetrical Gate Magnet Motor - Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        .info-panel { position: absolute; top: 10px; width: 100%; text-align: center; color: #ff5; font-family: 'Courier New', Courier, monospace; }
        .data-panel { position: absolute; top: 40px; left: 10px; color: #ff5; font-family: 'Courier New', Courier, monospace; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; border: 1px solid #ff5; }
        .controls-panel { position: absolute; bottom: 10px; left: 10px; color: #ff5; font-family: 'Courier New', Courier, monospace; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="info-panel">Symmetrical Gate Magnet Motor<br/>Drag rotor to feel forces.</div>
    <div id="data-overlay" class="data-panel"></div>
    <div id="controls" class="controls-panel">
        <input type="checkbox" id="toggleField" checked> <label for="toggleField">Show Magnetic Fields</label><br>
        <input type="checkbox" id="toggleForce" checked> <label for="toggleForce">Show Force Vector</label>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let scene, camera, renderer, controls;
            let rotor, statorMagnets = [], fieldLinesGroup, forceVector;
            let clock = new THREE.Clock();
            let rotorAngle = 0;
            let rotorVelocity = 0;
            const rotorFriction = 0.98;

            // --- SIMULATION PARAMETERS ---
            const ROTOR_MAGNET_STRENGTH = 1.5;
            const STATOR_MAGNET_STRENGTH = 2.0;
            const KICKER_MAGNET_STRENGTH = 2.5;

            function init() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 6, 5);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x0a0a10);
                document.body.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enablePan = false;

                createRotor();
                createStator();
                createFieldLines();
                createForceVector();
                createLighting();
                setupUI();

                animate();
            }

            function createRotor() {
                rotor = new THREE.Group();
                const rotorGeom = new THREE.CylinderGeometry(2, 2, 0.2, 64);
                const rotorMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.4 });
                rotor.add(new THREE.Mesh(rotorGeom, rotorMat));

                const magnetGeom = new THREE.BoxGeometry(0.5, 0.2, 0.8);
                const nMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.8, roughness: 0.5 });
                const sMat = new THREE.MeshStandardMaterial({ color: 0x0000ff, metalness: 0.8, roughness: 0.5 });
                
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const magnet = new THREE.Group();
                    const nPole = new THREE.Mesh(magnetGeom, nMat); nPole.position.z = 0.4;
                    const sPole = new THREE.Mesh(magnetGeom, sMat); sPole.position.z = -0.4;
                    magnet.add(nPole, sPole);
                    magnet.position.set(2.25 * Math.cos(angle), 0, 2.25 * Math.sin(angle));
                    magnet.lookAt(0,0,0);
                    magnet.userData = { type: 'rotor', strength: ROTOR_MAGNET_STRENGTH };
                    rotor.add(magnet);
                }
                scene.add(rotor);
            }

            function createStator() {
                const statorGeom = new THREE.TorusGeometry(3.5, 0.1, 16, 100);
                const statorMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.4 });
                scene.add(new THREE.Mesh(statorGeom, statorMat).rotateX(Math.PI/2));

                const channelGeom = new THREE.BoxGeometry(1.5, 0.4, 0.8);
                const kickerGeom = new THREE.BoxGeometry(0.3, 0.4, 0.6);
                const nMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.8, roughness: 0.5 });
                const sMat = new THREE.MeshStandardMaterial({ color: 0x0000ff, metalness: 0.8, roughness: 0.5 });

                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const statorGroup = new THREE.Group();
                    
                    const channel = new THREE.Mesh(channelGeom, sMat); // Attracting S-pole
                    channel.position.x = 3.5;
                    channel.userData = { type: 'stator', strength: STATOR_MAGNET_STRENGTH, pole: -1 };
                    statorGroup.add(channel);
                    statorMagnets.push(channel);

                    const kicker = new THREE.Mesh(kickerGeom, nMat); // Repelling N-pole
                    kicker.position.x = 2.6;
                    kicker.userData = { type: 'stator', strength: KICKER_MAGNET_STRENGTH, pole: 1 };
                    statorGroup.add(kicker);
                    statorMagnets.push(kicker);

                    statorGroup.rotation.y = angle;
                    scene.add(statorGroup);
                }
            }

            function createFieldLines() {
                fieldLinesGroup = new THREE.Group();
                const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
                for(let i=0; i<100; i++) {
                    const line = new THREE.Line(new THREE.BufferGeometry(), material);
                    fieldLinesGroup.add(line);
                }
                scene.add(fieldLinesGroup);
            }

            function createForceVector() {
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const geom = new THREE.CylinderGeometry(0, 0.1, 1, 8);
                forceVector = new THREE.Mesh(geom, material);
                forceVector.visible = false;
                scene.add(forceVector);
            }

            function createLighting() {
                scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const pointLight = new THREE.PointLight(0xffffff, 0.7);
                pointLight.position.set(0, 10, 5);
                scene.add(pointLight);
            }
            
            function setupUI() {
                document.getElementById('toggleField').addEventListener('change', (e) => fieldLinesGroup.visible = e.target.checked);
                document.getElementById('toggleForce').addEventListener('change', (e) => forceVector.visible = e.target.checked);
            }

            function updateFieldLines() {
                // Simplified field line visualization
                // In a real scenario, this would be a complex physics calculation
                let lineIndex = 0;
                rotor.children.forEach(rMag => {
                    if(!rMag.userData.type) return;
                    statorMagnets.forEach(sMag => {
                        const p1 = new THREE.Vector3();
                        rMag.getWorldPosition(p1);
                        const p2 = new THREE.Vector3();
                        sMag.getWorldPosition(p2);
                        const dist = p1.distanceTo(p2);
                        if(dist < 2.5 && lineIndex < fieldLinesGroup.children.length) {
                            const curve = new THREE.QuadraticBezierCurve3(p1, p1.clone().lerp(p2, 0.5).add(new THREE.Vector3(0, 1, 0)), p2);
                            fieldLinesGroup.children[lineIndex].geometry.setFromPoints(curve.getPoints(20));
                            lineIndex++;
                        }
                    });
                });
                for(let i=lineIndex; i<fieldLinesGroup.children.length; i++) {
                    fieldLinesGroup.children[i].geometry.setFromPoints([]);
                }
            }

            function calculateForces() {
                let netTangentialForce = 0;
                const testMagnet = rotor.children[1]; // Use one magnet for force calculation
                const rotorMagnetPos = new THREE.Vector3();
                testMagnet.getWorldPosition(rotorMagnetPos);
                const totalForce = new THREE.Vector3();

                statorMagnets.forEach(sMag => {
                    const statorMagnetPos = new THREE.Vector3();
                    sMag.getWorldPosition(statorMagnetPos);
                    const vec = new THREE.Vector3().subVectors(rotorMagnetPos, statorMagnetPos);
                    const distSq = vec.lengthSq();
                    const forceMag = (testMagnet.userData.strength * sMag.userData.strength) / distSq;
                    vec.normalize().multiplyScalar(forceMag * sMag.userData.pole);
                    totalForce.add(vec);
                });

                const tangent = new THREE.Vector3(-rotorMagnetPos.z, 0, rotorMagnetPos.x).normalize();
                netTangentialForce = totalForce.dot(tangent);

                // Update force vector visualization
                if(forceVector.visible) {
                    forceVector.position.copy(rotorMagnetPos);
                    forceVector.scale.y = totalForce.length() * 5;
                    forceVector.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), totalForce.clone().normalize());
                }
                
                return netTangentialForce;
            }

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                
                const tangentialForce = calculateForces();
                rotorVelocity += tangentialForce * delta * 0.5; // Apply force
                rotorVelocity *= rotorFriction; // Apply friction
                rotorAngle += rotorVelocity * delta;
                rotor.rotation.y = rotorAngle;

                if(fieldLinesGroup.visible) updateFieldLines();

                document.getElementById('data-overlay').innerHTML = `
                    <div>Rotor Speed: ${(rotorVelocity * 100).toFixed(2)} rad/s</div>
                    <div><b>Net Tangential Force: ${tangentialForce.toFixed(4)}</b></div>
                `;

                controls.update();
                renderer.render(scene, camera);
            }

            init();
        });
    </script>
</body>
</html>
